package com.justinquinnb.onefeed.customization.textstyle.parsing;

import com.justinquinnb.onefeed.customization.textstyle.*;
import com.justinquinnb.onefeed.customization.textstyle.markup.TextFormatting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.regex.Matcher;

/**
 * The default implementation of a {@link TextFormattingParser}, associating substrings with {@link TextFormatting}s.
 */
public final class BasicFormattingParser implements TextFormattingParser {
    private static final Logger logger = LoggerFactory.getLogger(BasicFormattingParser.class);

    @Override
    public FormattingKit parseFormattings(MarkedUpText markedUpText, FormatParsingRuleset rules) {
        logger.debug("Building FormattingKit for text: {}", markedUpText);

        // For clarity, the text actively being worked on, which may or may not contain any markup at any given time,
        // shall be referred to as the working text to distinguish it from the original, untouched markedUpText
        String workingText = markedUpText.getText();

        // Prepare the new FormattingInstruction ArrayList
        ArrayList<FormattingInstruction> instructions =
                new ArrayList<FormattingInstruction>();

        // Search for matches of each rule in the markedUpText and execute its associated method for every match,
        // building instructions with the results
        for (FormatParsingRule rule : rules) {
            SubstringLocation locationInFullStr; // The location of the generated replacement text in the markedUpText
            int matchStartIndex, matchEndOffset, replacementTextLength;
            FormattingMarkedText generatedFmt;
            TextFormatting generatedFormatting;

            logger.trace("Searching for substrings matching pattern: {}", rule.getRegex().toString());

            // Find matches in markedUpText for the current rule's Regex
            Matcher regexMatcher = rule.getRegex().matcher(workingText);

            // If the substring contains matches for the current rule's Regex, apply each rule to the match
            while (regexMatcher.find()) {
                // Get the position of the match
                matchStartIndex = regexMatcher.start();
                matchEndOffset = regexMatcher.end();

                // Extract the match and apply it according to the rule, saving the resultant unformatted text and
                // TextFormatting instance (bundled as FormattingMarkedText)
                MarkedUpText matchedText = new MarkedUpText(
                        workingText.substring(matchStartIndex, matchEndOffset), markedUpText.getMarkupLanguages());
                logger.trace("Markup match found: {}", matchedText.getText());

                try {
                    generatedFmt = rule.getParserFunction().parse(matchedText);
                } catch (MarkupLangMismatchException | ParseException e) {
                    logger.warn("Could not extract formatting from text: {}", matchedText);
                    generatedFmt = TextFormattingParser.FALLBACK_APPROACH.apply(matchedText);
                }

                logger.trace("Markup match labelled as \"{}\" with markup-stripped text: {}",
                        generatedFmt.getFormatting().toString(), generatedFmt.getText());

                // Replace the match with the FormattingMarkedText's unformatted text
                workingText = workingText.substring(0, matchStartIndex + 1) + // Original prefix
                        generatedFmt.getText() + // Now-unformatted text
                        workingText.substring(matchEndOffset); // Original suffix
                logger.trace("Working text now: {}", workingText);

                // Note the location of the now-unformatted text in the context of the larger markedUpString
                replacementTextLength = generatedFmt.getText().length();
                locationInFullStr = new SubstringLocation(matchStartIndex, (matchStartIndex + replacementTextLength) - 1);

                // Add this location and the TextFormatting generated by applying the rule to the list of instructions
                generatedFormatting = generatedFmt.getFormatting();
                logger.trace("Added instruction \"{} between {} and {}\" to FormattingKit",
                        generatedFormatting.toString(), locationInFullStr.getFirst(), locationInFullStr.getSecond());
                instructions.add(new FormattingInstruction(locationInFullStr, generatedFormatting));
            }

            logger.trace("All substrings matching pattern \"{}\" have been found", rule.getRegex().toString());
        }

        logger.debug("FormattingKit completed");
        return new FormattingKit(workingText, instructions);
    }
}