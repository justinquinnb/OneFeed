package com.justinquinnb.onefeed.customization.source;

import com.justinquinnb.onefeed.content.BasicContent;
import com.justinquinnb.onefeed.content.RawContent;
import com.justinquinnb.onefeed.content.details.ContentSourceId;
import com.justinquinnb.onefeed.content.details.Platform;
import com.justinquinnb.onefeed.customization.CustomizationHandler;
import com.justinquinnb.onefeed.customization.mapping.ContentMapper;
import com.justinquinnb.onefeed.customization.textstyle.parsing.FormatParsingRule;
import com.justinquinnb.onefeed.customization.textstyle.parsing.FormatParsingRuleset;

import java.time.Instant;

/**
 * Outlines the functionalities of a valid source of content.
 * @param <T> the type of {@link RawContent} {@code this} {@code ContentSource} produces
 */
public abstract class ContentSource<T extends RawContent> {
    /**
     * The unique {@code String} used to identify a specific {@code ContentSource} instance when interacting with the
     * OneFeed API. Facilitates the tracking of multiple {@code ContentSource} instances, a situation possible when
     * content is desired from multiple profiles on the same platform, for example.
     */
    public final ContentSourceId SOURCE_ID;

    /**
     * Information about the {@link Platform} the {@link ContentSource} is pulling data from.
     */
    protected Platform PLATFORM_INFO;

    /**
     * Instantiates a {@link ContentSource} with ID {@code sourceId} and the provided {@link #PLATFORM_INFO},
     * {@code platform}.
     *
     * @param sourceId the {@link ContentSourceId} to bind to the created {@code ContentSource} instance
     * @param platform information about the Platform the {@code ContentSource} pulls from
     *
     * @throws DuplicateCsIdException if the provided {@code sourceId} is already employed by another {@code ContentSource}
     * instance
     */
    protected ContentSource(ContentSourceId sourceId, Platform platform) throws DuplicateCsIdException {
        if (!CustomizationHandler.isCsIdAvailable(sourceId)) {
            throw new DuplicateCsIdException("ContentSourceId \"" + sourceId + "\" is already in use");
        }

        SOURCE_ID = sourceId;
        PLATFORM_INFO = platform;
    }

    /**
     * Checks if content can be retrieved from the desired source.
     *
     * @return {@code true} if the content is accessible, else {@code false}.
     */
    public abstract boolean isAvailable();

    /**
     * Gets the {@code count} latest units of {@link RawContent} from the source.
     *
     * @param count the amount of {@code RawContent} to retrieve
     *
     * @return at most {@code count}-many units of {@code RawContent} from the source. If less than {@code count}-many
     * units of {@code RawContent} can be retrieved, then all that could be retrieved is returned.
     */
    public abstract RawContent[] getLatestContent(int count);

    /**
     * Gets the {@code count} latest units of {@link RawContent} from the source between the specified
     * {@code betweenTimes}.
     *
     * @param count the amount of {@code RawContent} to retrieve
     * @param betweenTimes the {@link Instant}s that {@code RawContent} should fall between, element 0 indicating the
     *                    start and element 1 indicating the end, inclusive
     *
     * @return at most {@code count}-many units of {@code RawContent} between the specified {@code betweenTimes} from
     * the source. If less than {@code count}-many units of {@code RawContent} can be retrieved, then all that could
     * be retrieved is returned.
     */
    public abstract RawContent[] getLatestContent(int count, Instant[] betweenTimes);

    /**
     * Gets the {@link ContentMapper} necessary to convert the {@link RawContent} type {@code this}
     * {@code ContentSource} produces into {@link BasicContent}.
     *
     * @return the {@code ContentMapper} capable of converting the {@code RawContent} generated by {@code this}
     * {@link ContentSource} into {@link BasicContent}
     */
    public abstract ContentMapper<T, BasicContent> getContentMapper();

    /**
     * Maps {@code this} {@link ContentSource}'s {@link RawContent} type to the de-facto {@link BasicContent}.
     *
     * @param rawContent an array of the {@code RawContent} to map
     *
     * @return the provided {@code rawContent} mapped to {@code BasicContent}, order-preserved
     */
    public final BasicContent[] mapContent(T[] rawContent) {
        // Utilize this approach as opposed to repeated mapContent(T rawContent) invocations to minimize excess
        // memory allocation for the mapper instances when they're all the same
        ContentMapper<T, BasicContent> mapper = this.getContentMapper();
        BasicContent[] mappedContent = new BasicContent[rawContent.length];

        for (int i = 0; i < rawContent.length; i++) {
            mappedContent[i] = mapper.mapContent(rawContent[i]);
        }

        return mappedContent;
    }

    /**
     * Maps a piece {@code this} {@link ContentSource}'s {@link RawContent} type to the de-facto {@link BasicContent}.
     *
     * @param rawContent the single piece of {@code RawContent} to map
     *
     * @return the provided {@code rawContent} mapped to {@code BasicContent}
     */
    public final BasicContent mapContent(T rawContent) {
        ContentMapper<T, BasicContent> mapper = this.getContentMapper();
        return mapper.mapContent(rawContent);
    }

    /**
     * Gets the {@link FormatParsingRuleset} specifying how to interpret the formatting of text as it appears on
     * {@code this} {@link ContentSource}'s Platform.
     *
     * @return a set of {@link FormatParsingRule}s mapping regex that identifies formatted substrings in text
     * from this {@code ContentSource} to the function that can be used to de-format and label it.
     */
    public abstract FormatParsingRuleset<BasicFormatting> getFormatIndexingRuleset();

    /**
     * Gets an array of all of {@code this} {@link ContentSource}'s instances.
     *
     * @return an unordered array of all {@code this} {@code ContentSource}'s feeds/instances
     *
     * @implNote {@code ContentSource} developers are responsible for choosing how to approach feed creation and
     * configuration.
     * <br><br>
     * In most contexts, it's advised that one provides a configuration file where users can specify feed instances
     * for the {@code ContentSource} (or a helper class) to parse and instantiate {@code ContentSource}s from
     * accordingly. However, should a single-feed-only {@code ContentSource} be developed, one may opt to simply provide
     * a single instance of the {@code ContentSource} as-is.
     */
    public abstract ContentSource<T>[] getConfiguredFeeds();

    /**
     * Gets information about the {@link Platform} {@code this} {@link ContentSource} gets its data from.
     *
     * @return information about {@code this} {@code ContentSource}'s {@code Platform}
     */
    public final Platform getPlatformInfo() {
        return PLATFORM_INFO;
    }

    /**
     * Gets the unique {@link ContentSourceId} identifying the {@code ContentSource} instance.
     *
     * @return the unique {@link ContentSourceId} identifying the {@code ContentSource} instance
     */
    public final ContentSourceId getSourceId() {
        return SOURCE_ID;
    }

    /**
     * Checks if the {@code toCheck} {@link Instant} falls between {@code after} and {@code before}, inclusive.
     *
     * @param toCheck the {@code Instant} to check for inclusive belonging in the range ({@code after}, {@code before})
     * @param after the minimum time a "valid" {@code Instant} can be equal to
     * @param before the maximum time a "valid" {@code Instant} can be equal to
     *
     * @return {@code true} if {@code toCheck} exists in the range ({@code after}, {@code before}), else {@code false}.
     */
    public final boolean isInclusiveBetween(Instant toCheck, Instant after, Instant before) {
        boolean isBefore = toCheck.isBefore(before) || toCheck.equals(before);
        boolean isAfter = toCheck.isAfter(after) || toCheck.equals(after);
        return isBefore && isAfter;
    }

    /**
     * Returns a string representation of {@code this} {@code ContentSource}.
     *
     * @return a string representation of {@code this} {@code ContentSource}
     */
    @Override
    public String toString() {
        return "ContentSource@" + this.hashCode() +
                "{contentSourceId=\"" + this.SOURCE_ID.getId() +
                "\", platformInfo=" + this.PLATFORM_INFO +
                ", contentMapper=" + this.getContentMapper() +
                ", formattingRuleset=" + this.getFormatIndexingRuleset() + "}";
    }
}